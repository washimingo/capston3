{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ionic/core/dist/esm/notch-controller-lb417-kU.js"],
  "sourcesContent": ["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-ZjP4CjeZ.js';\nimport { r as raf } from './helpers-8KSQQGQy.js';\n\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n    let notchVisibilityIO;\n    const needsExplicitNotchWidth = () => {\n        const notchSpacerEl = getNotchSpacerEl();\n        if (\n        /**\n         * If the notch is not being used\n         * then we do not need to set the notch width.\n         */\n        notchSpacerEl === undefined ||\n            /**\n             * If either the label property is being\n             * used or the label slot is not defined,\n             * then we do not need to estimate the notch width.\n             */\n            el.label !== undefined ||\n            getLabelSlot() === null) {\n            return false;\n        }\n        return true;\n    };\n    const calculateNotchWidth = () => {\n        if (needsExplicitNotchWidth()) {\n            /**\n             * Run this the frame after\n             * the browser has re-painted the host element.\n             * Otherwise, the label element may have a width\n             * of 0 and the IntersectionObserver will be used.\n             */\n            raf(() => {\n                setNotchWidth();\n            });\n        }\n    };\n    /**\n     * When using a label prop we can render\n     * the label value inside of the notch and\n     * let the browser calculate the size of the notch.\n     * However, we cannot render the label slot in multiple\n     * places so we need to manually calculate the notch dimension\n     * based on the size of the slotted content.\n     *\n     * This function should only be used to set the notch width\n     * on slotted label content. The notch width for label prop\n     * content is automatically calculated based on the\n     * intrinsic size of the label text.\n     */\n    const setNotchWidth = () => {\n        const notchSpacerEl = getNotchSpacerEl();\n        if (notchSpacerEl === undefined) {\n            return;\n        }\n        if (!needsExplicitNotchWidth()) {\n            notchSpacerEl.style.removeProperty('width');\n            return;\n        }\n        const width = getLabelSlot().scrollWidth;\n        if (\n        /**\n         * If the computed width of the label is 0\n         * and notchSpacerEl's offsetParent is null\n         * then that means the element is hidden.\n         * As a result, we need to wait for the element\n         * to become visible before setting the notch width.\n         *\n         * We do not check el.offsetParent because\n         * that can be null if the host element has\n         * position: fixed applied to it.\n         * notchSpacerEl does not have position: fixed.\n         */\n        width === 0 &&\n            notchSpacerEl.offsetParent === null &&\n            win !== undefined &&\n            'IntersectionObserver' in win) {\n            /**\n             * If there is an IO already attached\n             * then that will update the notch\n             * once the element becomes visible.\n             * As a result, there is no need to create\n             * another one.\n             */\n            if (notchVisibilityIO !== undefined) {\n                return;\n            }\n            const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n                /**\n                 * If the element is visible then we\n                 * can try setting the notch width again.\n                 */\n                if (ev[0].intersectionRatio === 1) {\n                    setNotchWidth();\n                    io.disconnect();\n                    notchVisibilityIO = undefined;\n                }\n            }, \n            /**\n             * Set the root to be the host element\n             * This causes the IO callback\n             * to be fired in WebKit as soon as the element\n             * is visible. If we used the default root value\n             * then WebKit would only fire the IO callback\n             * after any animations (such as a modal transition)\n             * finished, and there would potentially be a flicker.\n             */\n            { threshold: 0.01, root: el }));\n            io.observe(notchSpacerEl);\n            return;\n        }\n        /**\n         * If the element is visible then we can set the notch width.\n         * The notch is only visible when the label is scaled,\n         * which is why we multiply the width by 0.75 as this is\n         * the same amount the label element is scaled by in the host CSS.\n         * (See $form-control-label-stacked-scale in ionic.globals.scss).\n         */\n        notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n    };\n    const destroy = () => {\n        if (notchVisibilityIO) {\n            notchVisibilityIO.disconnect();\n            notchVisibilityIO = undefined;\n        }\n    };\n    return {\n        calculateNotchWidth,\n        destroy,\n    };\n};\n\nexport { createNotchController as c };\n"],
  "mappings": ";;;;;;;;AAuBA,IAAM,wBAAwB,CAAC,IAAI,kBAAkB,iBAAiB;AAClE,MAAI;AACJ,QAAM,0BAA0B,MAAM;AAClC,UAAM,gBAAgB,iBAAiB;AACvC;AAAA;AAAA;AAAA;AAAA;AAAA,MAKA,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA,MAMd,GAAG,UAAU,UACb,aAAa,MAAM;AAAA,MAAM;AACzB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACA,QAAM,sBAAsB,MAAM;AAC9B,QAAI,wBAAwB,GAAG;AAO3B,UAAI,MAAM;AACN,sBAAc;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AAcA,QAAM,gBAAgB,MAAM;AACxB,UAAM,gBAAgB,iBAAiB;AACvC,QAAI,kBAAkB,QAAW;AAC7B;AAAA,IACJ;AACA,QAAI,CAAC,wBAAwB,GAAG;AAC5B,oBAAc,MAAM,eAAe,OAAO;AAC1C;AAAA,IACJ;AACA,UAAM,QAAQ,aAAa,EAAE;AAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAaA,UAAU,KACN,cAAc,iBAAiB,QAC/B,QAAQ,UACR,0BAA0B;AAAA,MAAK;AAQ/B,UAAI,sBAAsB,QAAW;AACjC;AAAA,MACJ;AACA,YAAM,KAAM,oBAAoB,IAAI;AAAA,QAAqB,CAAC,OAAO;AAK7D,cAAI,GAAG,CAAC,EAAE,sBAAsB,GAAG;AAC/B,0BAAc;AACd,eAAG,WAAW;AACd,gCAAoB;AAAA,UACxB;AAAA,QACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAUA,EAAE,WAAW,MAAM,MAAM,GAAG;AAAA,MAAC;AAC7B,SAAG,QAAQ,aAAa;AACxB;AAAA,IACJ;AAQA,kBAAc,MAAM,YAAY,SAAS,GAAG,QAAQ,IAAI,IAAI;AAAA,EAChE;AACA,QAAM,UAAU,MAAM;AAClB,QAAI,mBAAmB;AACnB,wBAAkB,WAAW;AAC7B,0BAAoB;AAAA,IACxB;AAAA,EACJ;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;",
  "names": []
}
